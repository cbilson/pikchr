%include {
/*
** 2020-09-01
**
** A translator for the PIC language into SVG.
**
** This code was originally written by D. Richard Hipp using documentation
** from prior PIC implementations but without reference to prior code.
** All of the code in this project is original.  The author releases all
** code into the public domain.
**
** This file implements a C-language subroutine that accepts a string
** of PIC language text and generates a second string of SVG output that
** renders the drawing defined by the input.  Space to hold the returned
** string is obtained from malloc() and should be freed by the caller.
** NULL might be returned if there is a memory allocation error.
**
** If there are error in the PIC input, the output will consist of an
** error message and the original PIC input text (inside of <pre>...</pre>).
**
** The subroutine implemented by this file is intended to be stand-alone.
** It uses no external routines other than routines commonly found in
** the standard C library.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#define count(X) (sizeof(X)/sizeof(X[0]))

typedef struct Pic Pic;
typedef struct PToken PToken;

/* A single token in the parser input stream
*/
struct PToken {
  const char *z;           /* Pointer to the token text */
  unsigned int n;          /* Length of the token in bytes */
  int eCode;               /* Auxiliary code */
};

/* Extra token types not generated by LEMON */
#define T_WHITESPACE 1000
#define T_ERROR      1001

/* Each call to the pic() subroutine uses an instance of the following
** object to pass around context to all of its subroutines.
*/
struct Pic {
  unsigned nErr;           /* Number of errors seen */
  const char *zIn;         /* Input PIC-language text.  zero-terminated */
  unsigned int nIn;        /* Number of bytes in zIn */
  char *zOut;              /* Result accumulates here */
  unsigned int nOut;       /* Bytes written to zOut[] so far */
  unsigned int nOutAlloc;  /* Space allocated to zOut[] */
  int eDir;                /* Current direction */
};


} // end %include

%name pic_parser
%token_prefix T_
%token_type {PToken}
%extra_context {Pic *p}


document ::= element_list.

element_list ::= element.
element_list ::= element_list EOL element.
element ::= .
element ::= direction.
element ::= ID ASSIGN expr.
element ::= PLACENAME COLON unnamed_element.
element ::= unnamed_element.
unnamed_element ::= basetype attribute_list.

basetype ::= ID.
basetype ::= STRING.
basetype ::= LB element_list RB.

direction ::= UP.
direction ::= DOWN.
direction ::= LEFT.
direction ::= RIGHT.

attribute_list ::=.
attribute_list ::= attribute_list attribute.
attribute ::= numproperty expr PERCENT.
attribute ::= numproperty expr.
attribute ::= dashproperty expr.
attribute ::= dashproperty.
attribute ::= colorproperty expr.
attribute ::= direction expr.
attribute ::= direction.
attribute ::= FROM position.
attribute ::= TO position.
attribute ::= THEN.
attribute ::= boolproperty.
attribute ::= AT position.
attribute ::= WITH DOT_E EDGE AT position.
attribute ::= WITH EDGE AT position.
attribute ::= SAME.
attribute ::= SAME AS object.
attribute ::= BEHIND object.
attribute ::= STRING textposition.

// Properties that require an argument
numproperty ::= HEIGHT.
numproperty ::= WIDTH.
numproperty ::= RADIUS.
numproperty ::= RX.
numproperty ::= RY.
numproperty ::= DIAMETER.
numproperty ::= THICKNESS.

// Properties with optional arguments
dashproperty ::= DOTTED.
dashproperty ::= DASHED.
dashproperty ::= CHOP.

// Color properties
colorproperty ::= FILL.
colorproperty ::= COLOR.

// Properties with no argument
boolproperty ::= CW.
boolproperty ::= CCW.
boolproperty ::= LARROW.
boolproperty ::= RARROW.
boolproperty ::= LRARROW.
boolproperty ::= INVIS.

textposition ::= .
textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW.


position ::= expr COMMA expr.
position ::= place.
position ::= place PLUS expr COMMA expr.
position ::= place MINUS expr COMMA expr.
position ::= place PLUS LP expr COMMA expr RP.
position ::= place MINUS LP expr COMMA expr RP.
position ::= LP position COMMA position RP.
position ::= LP position RP.
position ::= expr OF THE WAY BETWEEN position AND position.
position ::= expr BETWEEN position AND position.
position ::= direction expr FROM position.
position ::= DISTANCE expr ANGLE expr FROM position.

place ::= object.
place ::= object DOT_E EDGE.
place ::= object DOT_L START.
place ::= object DOT_L END.
place ::= START OF object.
place ::= END OF object.
place ::= EDGE OF object.

object ::= objectname.
object ::= nth.
object ::= nth OF|IN object.

objectname ::= PLACENAME.
objectname ::= objectname DOT_U PLACENAME.

nth ::= NTH ID.
nth ::= NTH LAST ID.
nth ::= LAST ID.
nth ::= NTH LB RB.
nth ::= NTH LAST LB RB.
nth ::= LAST LB RB.

%left OF.
%left PLUS MINUS.
%left STAR SLASH PERCENT.
%right UMINUS.

expr ::= expr PLUS expr.
expr ::= expr MINUS expr.
expr ::= expr STAR expr.
expr ::= expr SLASH expr.
expr ::= MINUS expr. [UMINUS]
expr ::= PLUS expr. [UMINUS]
expr ::= LP expr RP.
expr ::= ID.
expr ::= NUMBER.
expr ::= HEXRGB.
expr ::= object DOT_L locproperty.
expr ::= object DOT_L numproperty.
expr ::= object DOT_L dashproperty.
expr ::= object DOT_L colorproperty.
expr ::= LP locproperty OF object RP.
expr ::= LP dashproperty OF object RP.
expr ::= LP numproperty OF object RP.
expr ::= LP colorproperty OF object RP.
expr ::= object DOT_E EDGE DOT_L X.
expr ::= object DOT_E EDGE DOT_L Y.
expr ::= FUNCNAME LP expr RP.
expr ::= FUNCNAME LP expr COMMA expr RP.

locproperty ::= X.
locproperty ::= Y.
locproperty ::= TOP.
locproperty ::= BOTTOM.
locproperty ::= LEFT.
locproperty ::= RIGHT.


%code {

/*
** An array of this structure defines a list of keywords.
*/
struct PicWordlist {
  char *zWord;    /* Text of the keyword */
  int nChar;      /* Length of keyword text in bytes */
  int eType;      /* Token code */
};

/*
** Keywords
*/
static struct PicWordlist pic_keywords[] = {
  { "above",      5,   T_ABOVE     },
  { "and",        3,   T_AND       },
  { "angle",      5,   T_ANGLE     },
  { "as",         2,   T_AS        },
  { "at",         2,   T_AT        },
  { "atan2",      5,   T_FUNCNAME  },
  { "behind",     6,   T_BEHIND    },
  { "below",      5,   T_BELOW     },
  { "between",    7,   T_BETWEEN   },
  { "bottom",     6,   T_BOTTOM    },
  { "ccw",        3,   T_CCW       },
  { "center",     6,   T_CENTER    },
  { "chop",       4,   T_CHOP      },
  { "color",      5,   T_COLOR     },
  { "cos",        3,   T_FUNCNAME  },
  { "cw",         2,   T_CW        },
  { "dashed",     6,   T_DASHED    },
  { "diameter",   8,   T_DIAMETER  },
  { "distance",   8,   T_DISTANCE  },
  { "dotted",     6,   T_DOTTED    },
  { "down",       4,   T_DOWN      },
  { "e",          1,   T_EDGE      },
  { "end",        3,   T_END       },
  { "exp",        3,   T_FUNCNAME  },
  { "fill",       4,   T_FILL      },
  { "from",       4,   T_FROM      },
  { "height",     6,   T_HEIGHT    },
  { "in",         2,   T_IN        },
  { "int",        3,   T_FUNCNAME  },
  { "invisible",  9,   T_INVIS     },
  { "last",       4,   T_LAST      },
  { "left",       4,   T_LEFT      },
  { "ljust",      5,   T_LJUST     },
  { "log",        3,   T_FUNCNAME  },
  { "max",        3,   T_FUNCNAME  },
  { "min",        3,   T_FUNCNAME  },
  { "n",          1,   T_EDGE      },
  { "ne",         2,   T_EDGE      },
  { "nw",         2,   T_EDGE      },
  { "of",         2,   T_OF        },
  { "radius",     6,   T_RADIUS    },
  { "right",      5,   T_RIGHT     },
  { "rjust",      5,   T_RJUST     },
  { "rx",         2,   T_RX        },
  { "ry",         2,   T_RY        },
  { "s",          1,   T_EDGE      },
  { "same",       4,   T_SAME      },
  { "se",         2,   T_EDGE      },
  { "sin",        3,   T_FUNCNAME  },
  { "sqrt",       4,   T_FUNCNAME  },
  { "start",      5,   T_START     },
  { "sw",         2,   T_EDGE      },
  { "the",        3,   T_THE       },
  { "then",       4,   T_THEN      },
  { "thickness",  9,   T_THICKNESS },
  { "to",         2,   T_TO        },
  { "top",        3,   T_TOP       },
  { "up",         2,   T_UP        },
  { "w",          1,   T_EDGE      },
  { "way",        3,   T_WAY       },
  { "width",      5,   T_WIDTH     },
  { "with",       4,   T_WITH      },
  { "x",          1,   T_X         },
  { "y",          1,   T_Y         },
};

/*
** Search a PicWordlist for the given keyword.  Return its code.
** Or return 0 if not found.
*/
static int pic_find_word(
  const char *zIn,              /* Word to search for */
  int n,                        /* Length of zIn */
  struct PicWordlist *aList,    /* List to search */
  int nList                     /* Number of entries in aList */
){
  int first = 0;
  int last = nList-1;
  while( first<=last ){
    int mid = (first + last)/2;
    int sz = aList[mid].nChar;
    int c = strncmp(zIn, aList[mid].zWord, sz<n ? sz : n);
    if( c==0 ){
      c = n - sz;
      if( c==0 ) return aList[mid].eType;
    }
    if( c<0 ){
      last = mid-1;
    }else{
      first = mid+1;
    }
  }
  return 0;
}


/*
** Return the length of next token  Write token type into *peType
*/
static int pic_token_length(const char *zStart, int *peType){
  int i;
  char c;
  switch( zStart[0] ){
    case '\\': {
      *peType = T_WHITESPACE;
      if( zStart[1]=='\n'  ) return 2;
      if( zStart[1]=='\r' && zStart[2]=='\n' ) return 3;
      *peType = T_ERROR;
      return 1;
    }
    case ';':
    case '\n': {
      *peType = T_EOL;
      return 1;
    }
    case '"': {
      for(i=1; (c = zStart[i])!=0; i++){
        if( c=='\\' ){ i++; continue; }
        if( c=='"' ){
          *peType = T_STRING;
          return i+1;
        }
      }
      *peType = T_ERROR;
      return i;
    }
    case ' ':
    case '\t':
    case '\f':
    case '\r': {
      for(i=1; (c = zStart[i])==' ' || c=='\t' || c=='\r' || c=='\t'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '#': {
      for(i=1; isxdigit(zStart[i]); i++){}
      if( i==4 || i==7 ){
        *peType = T_HEXRGB;
        return i;
      }
      for(i=1; (c = zStart[i])!=0 && c!='\n'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '+': {   *peType = T_PLUS;    return 1; }
    case '*': {   *peType = T_STAR;    return 1; }
    case '/': {   *peType = T_SLASH;   return 1; }
    case '%': {   *peType = T_PERCENT; return 1; }
    case '(': {   *peType = T_LP;      return 1; }
    case ')': {   *peType = T_RP;      return 1; }
    case '[': {   *peType = T_LB;      return 1; }
    case ']': {   *peType = T_RB;      return 1; }
    case ',': {   *peType = T_COMMA;   return 1; }
    case ':': {   *peType = T_COLON;   return 1; }
    case '=': {   *peType = T_ASSIGN;  return 1; }
    case '-': {
      if( zStart[1]=='>' ){
        *peType = T_RARROW;
        return 2;
      }else{
        *peType = T_MINUS;
        return 1;
      }
    }
    case '<': { 
      if( zStart[1]=='-' ){
         if( zStart[2]=='>' ){
           *peType = T_LRARROW;
           return 3;
         }else{
           *peType = T_LARROW;
           return 2;
         }
      }else{
        *peType = T_ERROR;
         return 1;
      }
    }
    default: {
      c = zStart[0];
      if( c=='.' ){
        char c1 = zStart[1];
        if( c1>='a' && c1<='z' ){
          for(i=2; (c = zStart[i])>='a' && c<='z'; i++){}
          if( T_EDGE==pic_find_word(zStart+1, i-1,
                                    pic_keywords, count(pic_keywords)) ){
            *peType = T_DOT_E;
          }else{
            *peType = T_DOT_L;
          }
          return 1;
        }else if( c1>='0' && c1<='9' ){
          /* no-op.  Fall through to number handling */
        }else if( c1>='A' && c1<='Z' ){
          for(i=2; (c = zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
          *peType = T_DOT_U;
          return 1;
        }else{
          *peType = T_ERROR;
          return 1;
        }
      }
      if( (c>='0' && c<='9') || c=='.' ){
        int nDigit;
        if( c!='.' ){
          nDigit = 1;
          for(i=1; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }else{
          nDigit = 0;
        }
        if( c=='.' ){
          for(i++; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }
        if( nDigit==0 ){
          *peType = T_ERROR;
          return i;
        }
        if( c=='e' || c=='E' ){
          i++;
          c = zStart[i];
          if( c=='+' || c=='-' ){
            i++;
            c = zStart[i];
          }
          if( c<'0' || c>'9' ){
            *peType = T_ERROR;
            return i;
          }
          i++;
          while( (c = zStart[i])>=0 && c<='9' ){ i++; }
        }else if( (c=='t' && zStart[i+1]=='h')
               || (c=='r' && zStart[i+1]=='d')
               || (c=='n' && zStart[i+1]=='d')
               || (c=='s' && zStart[i+1]=='t') ){
          *peType = T_NTH;
          return i+2;
        }
        *peType = T_NUMBER;
        return i;
      }else if( c>='a' && c<='z' ){
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        *peType = pic_find_word(zStart, i,
                   pic_keywords, count(pic_keywords));
        if( *peType==0 ) *peType = T_ID;
        return i;
      }else if( c>='A' && c<='Z' ){
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        *peType = T_PLACENAME;
        return i;
      }else{
        *peType = T_ERROR;
        return 1;
      }
    }
  }
}

/*
** Parse the PIC script contained in zText[]
*/
char *pic(const char *zText, int *pnErr){
  int i;
  int sz;
  int eType;
  PToken token;
  Pic s;
  yyParser sParse;
  memset(&s, 0, sizeof(s));
  s.zIn = zText;
  s.nIn = (unsigned int)strlen(zText);
  pic_parserInit(&sParse, &s);
  pic_parserTrace(stdout, "parser: ");
  for(i=0; zText[i] && s.nErr==0; i+=sz){
    sz = pic_token_length(zText+i, &eType);
    if( eType==T_ERROR ){
      printf("Unknown token at position %d: \"%.*s\"\n", i, sz, zText+i);
      break;
    }else if( eType!=T_WHITESPACE ){
      token.z = zText + i;
      token.n = sz;
      token.eCode = eType;
printf("******** Token %s (%d): \"%.*s\" **************\n",
 yyTokenName[eType], eType, isspace(token.z[0]) ? 0 : token.n, token.z);
      pic_parser(&sParse, eType, token);
    }
  }
  if( s.nErr==0 ){
    memset(&token,0,sizeof(token));
    pic_parser(&sParse, 0, token);
  }
  pic_parserFinalize(&sParse);
  if( pnErr ) *pnErr = s.nErr;
  if( s.zOut ){
    s.zOut[s.nOut] = 0;
    s.zOut = realloc(s.zOut, s.nOut+1);
  }
  return s.zOut;
}

int main(int argc, char **argv){
  int i;
  for(i=1; i<argc; i++){
    FILE *in;
    size_t sz;
    char *zIn;
    char *zOut;

    in = fopen(argv[i], "rb");
    if( in==0 ){
      fprintf(stderr, "cannot open \"%s\" for reading\n", argv[i]);
      continue;
    }
    fseek(in, 0, SEEK_END);
    sz = ftell(in);
    rewind(in);
    zIn = malloc( sz+1 );
    if( zIn==0 ){
      fprintf(stderr, "cannot allocate space for file \"%s\"\n", argv[i]);
      fclose(in);
      continue;
    }
    sz = fread(zIn, 1, sz, in);
    fclose(in);
    zIn[sz] = 0;
    zOut = pic(zIn, 0);
    free(zIn);
    if( zOut ){
      printf("%s", zOut);
      free(zOut);
    }
  }
  return 0; 
}

} // end %code
