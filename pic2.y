%include {
/*
** 2020-09-01
**
** A translator for the PIC language into SVG.
**
** This code was originally written by D. Richard Hipp using documentation
** from prior PIC implementations but without reference to prior code.
** All of the code in this project is original.  The author releases all
** code into the public domain.
**
** This file implements a C-language subroutine that accepts a string
** of PIC language text and generates a second string of SVG output that
** renders the drawing defined by the input.  Space to hold the returned
** string is obtained from malloc() and should be freed by the caller.
** NULL might be returned if there is a memory allocation error.
**
** If there are error in the PIC input, the output will consist of an
** error message and the original PIC input text (inside of <pre>...</pre>).
**
** The subroutine implemented by this file is intended to be stand-alone.
** It uses no external routines other than routines commonly found in
** the standard C library.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#define count(X) (sizeof(X)/sizeof(X[0]))

typedef struct Pic Pic;          /* Complete parsing context */
typedef struct PToken PToken;    /* A single token */
typedef struct PElem PElem;      /* A single element */
typedef struct PEList PEList;    /* A list of elements */
typedef struct PClass PClass;    /* Description of elements types */
typedef double PNum;             /* Numeric value */
typedef struct PPoint PPoint;    /* A position in 2-D space */


/* An object to hold a position in 2-D space */
struct PPoint {
  PNum x, y;               /* X and Y coordinates */
};

/* A single token in the parser input stream
*/
struct PToken {
  const char *z;           /* Pointer to the token text */
  unsigned int n;          /* Length of the token in bytes */
  int eCode;               /* Auxiliary code */
};

/* Extra token types not generated by LEMON */
#define T_WHITESPACE 1000
#define T_ERROR      1001

/* Different types of elements */
struct PClass {
  const char *zName;
};

/* A single element */
struct PElem {
  const PClass *type;      /* Element type */
  PEList *pSublist;        /* Substructure for [] elements */
  char *zName;             /* Name assigned to this element */
};

/* A list of elements */
struct PEList {
  int n;          /* Number of elements in the list */
  int nAlloc;     /* Allocated slots in a[] */
  PElem **a;      /* Pointers to individual elements */
};

/* Each call to the pic() subroutine uses an instance of the following
** object to pass around context to all of its subroutines.
*/
struct Pic {
  unsigned nErr;           /* Number of errors seen */
  const char *zIn;         /* Input PIC-language text.  zero-terminated */
  unsigned int nIn;        /* Number of bytes in zIn */
  char *zOut;              /* Result accumulates here */
  unsigned int nOut;       /* Bytes written to zOut[] so far */
  unsigned int nOutAlloc;  /* Space allocated to zOut[] */
  int eDir;                /* Current direction */
  PElem *cur;              /* Element under construction */
};

/* Forward declarations */
static void pic_append(Pic*, const char*,int);
static void pic_append_text(Pic*,const char*,int);
static void pic_error(Pic*,PToken*,const char*);
static void pic_elist_free(Pic*,PEList*);
static void pic_elem_free(Pic*,PElem*);
static void pic_render(Pic*,PEList*);
static PEList *pic_elist_append(Pic*,PEList*,PElem*);
static PElem *pic_elem_new(Pic*,PToken*,PToken*,PEList*);
static void pic_elem_setname(Pic*,PElem*,PToken*);
static void pic_debug_print_expr(Pic*,PNum);


} // end %include

%name pic_parser
%token_prefix T_
%token_type {PToken}
%extra_context {Pic *p}

%type element_list {PEList*}
%destructor element_list {pic_elist_free(p,$$);}
%type element {PElem*}
%destructor element {pic_elem_free(p,$$);}
%type unnamed_element {PElem*}
%destructor unnamed_element {pic_elem_free(p,$$);}
%type basetype {PElem*}
%destructor basetype {pic_elem_free(p,$$);}
%type expr {PNum}


document ::= element_list(X).  {pic_render(p,X);}


element_list(A) ::= element(X).   { A = pic_elist_append(p,0,X); }
element_list(A) ::= element_list(B) EOL element(X).
                      { A = pic_elist_append(p,B,X); }


element(A) ::= .   { A = 0; }
element(A) ::= direction.  { A = 0; }
element(A) ::= ID ASSIGN expr. {A = 0;}
element(A) ::= PRINT expr(X). {pic_debug_print_expr(p,X); A=0;}
element(A) ::= PLACENAME(N) COLON unnamed_element(X).
               { A = X;  pic_elem_setname(p,X,&N); }
element(A) ::= unnamed_element(X).  {A = X;}

unnamed_element(A) ::= basetype(X) attribute_list.  {A = X;}

basetype(A) ::= ID(N).                  {A = pic_elem_new(p,&N,0,0); }
basetype(A) ::= STRING(N).              {A = pic_elem_new(p,0,&N,0); }
basetype(A) ::= LB element_list(X) RB.  {A = pic_elem_new(p,0,0,X);}

direction ::= UP.
direction ::= DOWN.
direction ::= LEFT.
direction ::= RIGHT.

attribute_list ::=.
attribute_list ::= attribute_list attribute.
attribute ::= numproperty expr PERCENT.
attribute ::= numproperty expr.
attribute ::= dashproperty expr.
attribute ::= dashproperty.
attribute ::= colorproperty expr.
attribute ::= direction expr.
attribute ::= direction.
attribute ::= FROM position.
attribute ::= TO position.
attribute ::= THEN.
attribute ::= boolproperty.
attribute ::= AT position.
attribute ::= WITH DOT_E EDGE AT position.
attribute ::= WITH EDGE AT position.
attribute ::= SAME.
attribute ::= SAME AS object.
attribute ::= BEHIND object.
attribute ::= STRING textposition.

// Properties that require an argument
numproperty ::= HEIGHT.
numproperty ::= WIDTH.
numproperty ::= RADIUS.
numproperty ::= RX.
numproperty ::= RY.
numproperty ::= DIAMETER.
numproperty ::= THICKNESS.

// Properties with optional arguments
dashproperty ::= DOTTED.
dashproperty ::= DASHED.
dashproperty ::= CHOP.

// Color properties
colorproperty ::= FILL.
colorproperty ::= COLOR.

// Properties with no argument
boolproperty ::= CW.
boolproperty ::= CCW.
boolproperty ::= LARROW.
boolproperty ::= RARROW.
boolproperty ::= LRARROW.
boolproperty ::= INVIS.

textposition ::= .
textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW.


position ::= expr COMMA expr.
position ::= place.
position ::= place PLUS expr COMMA expr.
position ::= place MINUS expr COMMA expr.
position ::= place PLUS LP expr COMMA expr RP.
position ::= place MINUS LP expr COMMA expr RP.
position ::= LP position COMMA position RP.
position ::= LP position RP.
position ::= expr OF THE WAY BETWEEN position AND position.
position ::= expr BETWEEN position AND position.
position ::= direction expr FROM position.
position ::= DISTANCE expr ANGLE expr FROM position.

place ::= object.
place ::= object DOT_E EDGE.
place ::= object DOT_L START.
place ::= object DOT_L END.
place ::= START OF object.
place ::= END OF object.
place ::= EDGE OF object.

object ::= objectname.
object ::= nth.
object ::= nth OF|IN object.

objectname ::= PLACENAME.
objectname ::= objectname DOT_U PLACENAME.

nth ::= NTH ID.
nth ::= NTH LAST ID.
nth ::= LAST ID.
nth ::= NTH LB RB.
nth ::= NTH LAST LB RB.
nth ::= LAST LB RB.

%left OF.
%left PLUS MINUS.
%left STAR SLASH PERCENT.
%right UMINUS.

expr(A) ::= expr(X) PLUS expr(Y).     {A=X+Y;}
expr(A) ::= expr(X) MINUS expr(Y).    {A=X-Y;}
expr(A) ::= expr(X) STAR expr(Y).     {A=X*Y;}
expr(A) ::= expr(X) SLASH(E) expr(Y).    {
  if( Y==0.0 ){
    pic_error(p, &E, "division by zero");
    A = 0.0;
  }else{
    A = X/Y;
  }
}
expr(A) ::= MINUS expr(X). [UMINUS]  {A=-X;}
expr(A) ::= PLUS expr(X). [UMINUS]   {A=X;}
expr(A) ::= LP expr(X) RP.           {A=X;}
expr(A) ::= NUMBER(N).               {A=atof(N.z);}
expr ::= ID.
expr ::= HEXRGB.
expr ::= object DOT_L locproperty.
expr ::= object DOT_L numproperty.
expr ::= object DOT_L dashproperty.
expr ::= object DOT_L colorproperty.
expr ::= LP locproperty OF object RP.
expr ::= LP dashproperty OF object RP.
expr ::= LP numproperty OF object RP.
expr ::= LP colorproperty OF object RP.
expr ::= object DOT_E EDGE DOT_L X.
expr ::= object DOT_E EDGE DOT_L Y.
expr ::= FUNCNAME LP expr RP.
expr ::= FUNCNAME LP expr COMMA expr RP.

locproperty ::= X.
locproperty ::= Y.
locproperty ::= TOP.
locproperty ::= BOTTOM.
locproperty ::= LEFT.
locproperty ::= RIGHT.


%code {

/*
** The following array holds all the different kinds of named
** elements.  The special STRING and [] elements are separate.
*/
static const PClass aClass[] = {
   {  "box",      },
   {  "arrow",    },
   {  "circle",   },
   {  "ellipse",  },
   {  "arc",      },
   {  "line",     },
   {  "spline",   },
   {  "move",     },
   {  "cylinder", },
   {  "document", },
   {  "folder",   }
};
static const PClass sublistClass = { "[]", };
static const PClass textClass = { "TEXT", };


/*
** Append raw text to zOut
*/
static void pic_append(Pic *p, const char *zText, int n){
  if( n<0 ) n = (int)strlen(zText);
  if( p->nOut+n>=p->nOutAlloc ){
    int nNew = (p->nOut+n)*2 + 1;
    char *z = realloc(p->zOut, nNew);
    if( z==0 ){
      pic_error(p, 0, 0);
      return;
    }
    p->zOut = z;
    p->nOutAlloc = n;
  }
  memcpy(p->zOut+p->nOut, zText, n);
  p->nOut += n;
  p->zOut[p->nOut] = 0;
}

/*
** Append text to zOut with HTML characters escaped.
*/
static void pic_append_text(Pic *p, const char *zText, int n){
  int i;
  char c;
  if( n<0 ) n = (int)strlen(zText);
  while( n>0 ){
    for(i=0; i<n && (c=zText[i])!='<' && c!='>' && c!='&' && c!='"'; i++){}
    if( i ) pic_append(p, zText, i);
    if( i==n ) break;
    switch( c ){
      case '<': {  pic_append(p, "&lt;", 4);  break;  }
      case '>': {  pic_append(p, "&gt;", 4);  break;  }
      case '&': {  pic_append(p, "&amp;", 5);  break;  }
      case '"': {  pic_append(p, "&quote;", 7);  break;  }
    }
    i++;
    n -= i;
    zText += i;
    i = 0;
  }
}

/*
** Generate an error message for the output.  pErr is the token at which
** the error should point.  zMsg is the text of the error message. If
** either pErr or zMsg is NULL, generate an out-of-memory error message.
**
** This routine is a no-op if there has already been an error reported.
*/
static void pic_error(Pic *p, PToken *pErr, const char *zMsg){
  int i;
  if( p->nErr ) return;
  p->nErr++;
  p->nOut = 0;
  i = (int)(pErr->z - p->zIn);
  if( pErr==0 || zMsg==0 ){
    pic_append_text(p, "<div><p class='err'>Out of memory</p></div>\n", -1);
    return;
  }
  pic_append(p, "<div><pre>\n", -1);
  pic_append_text(p, p->zIn, i);
  pic_append(p, "<span class='err'>&rarr;", -1);
  pic_append_text(p, p->zIn+i, pErr->n);
  pic_append(p, "&larr;", -1);
  pic_append_text(p, zMsg, -1);
  pic_append(p, "</span>", -1);
  i += pErr->n;
  pic_append_text(p,  p->zIn+i, -1);
  pic_append(p, "\n</pre></div>\n", -1);
}

/* Output an expresion value in a comment for debugging purposes */
static void pic_debug_print_expr(Pic *p, PNum x){
  char zBuf[100];
  pic_append(p, "<!-- ", -1);
  snprintf(zBuf, sizeof(zBuf)-1, "%g", (double)x);
  pic_append(p, zBuf, -1);
  pic_append(p, " -->\n", -1);
}


/* Free a complete list of elements */
static void pic_elist_free(Pic *p, PEList *pEList){
  int i;
  if( pEList==0 ) return;
  for(i=0; i<pEList->n; i++){
    pic_elem_free(p, pEList->a[i]);
  }
  free(pEList->a);
  free(pEList);
  return;
}

/* Free a single element, and its substructure */
static void pic_elem_free(Pic *p, PElem *pElem){
  if( pElem==0 ) return;
  free(pElem->zName);
  pic_elist_free(p, pElem->pSublist);
  free(pElem);
}


/* Append a new element onto the end of an element_list.  The
** element_list is created if it does not already exist.  Return
** the new element list.
*/
static PEList *pic_elist_append(Pic *p, PEList *pEList, PElem *pElem){
  if( pElem==0 ) return pEList;
  if( pEList==0 ){
    pEList = malloc(sizeof(*pEList));
    if( pEList==0 ){
      pic_error(p, 0, 0);
      pic_elem_free(p, pElem);
      return 0;
    }
    memset(pEList, 0, sizeof(*pEList));
  }
  if( pEList->n>=pEList->nAlloc ){
    int nNew = (pEList->n+5)*2;
    PElem **pNew = realloc(pEList->a, sizeof(PElem*)*nNew);
    if( pNew==0 ){
      pic_error(p, 0, 0);
      pic_elem_free(p, pElem);
      return pEList;
    }
    pEList->a = pNew;
  }
  pEList->a[pEList->n++] = pElem;   
  return pEList;
}

/* Allocate and return a new PElem object.
*/
static PElem *pic_elem_new(Pic *p, PToken *pId, PToken *pStr, PEList *pSublist){
  PElem *pNew;

  pNew = malloc( sizeof(*pNew) );
  if( pNew==0 ){
    pic_error(p,0,0);
    pic_elist_free(p, pSublist);
    return 0;
  }
  memset(pNew, 0, sizeof(*pNew));
  if( pSublist ){
    pNew->type = &sublistClass;
    pNew->pSublist = pSublist;
    return pNew;
  }
  if( pStr ){
    pNew->type = &textClass;
    return pNew;
  }
  if( pId ){
    int i;
    for(i=0; i<count(aClass); i++){
      if( strncmp(aClass[i].zName, pId->z, pId->n)==0 
       && aClass[i].zName[pId->n]==0
      ){
        pNew->type = &aClass[i];
        return pNew;
      }
    }
    pic_error(p, pId, "unknown element type");
  }
  pic_elem_free(p, pNew);
  return 0;
}

/* Attach a name to an element
*/
static void pic_elem_setname(Pic *p, PElem *pElem, PToken *pName){
  if( pElem==0 ) return;
  if( pName==0 ) return;
  free(pElem->zName);
  pElem->zName = malloc(pName->n+1);
  if( pElem->zName==0 ){
    pic_error(p,0,0);
  }else{
    memcpy(pElem->zName,pName->z,pName->n);
    pElem->zName[pName->n] = 0;
  }
  return;
}

/* Render a single element
*/
static void pic_elem_render(Pic *p, PElem *pElem){
  if( pElem==0 ) return;
  if( pElem->zName ){
    pic_append_text(p, pElem->zName, -1);
    pic_append(p, ": ", 2);
  }
  if( pElem->pSublist ){
    pic_append(p, "[\n", 2);
    pic_render(p,pElem->pSublist);
    pElem->pSublist = 0;
    pic_append(p, "]\n", 2);
  }else{
    pic_append_text(p, pElem->type->zName, -1);
    pic_append(p, "\n", 1);
  }
}

/* Render a list of elements.  Write the SVG into p->zOut.
** Delete the input element_list before returnning.
*/
static void pic_render(Pic *p, PEList *pEList){
  int i;
  if( pEList==0 ) return;
  if( p->nErr==0 ){
    for(i=0; i<pEList->n; i++){
      pic_elem_render(p, pEList->a[i]);
    }
  }
  pic_elist_free(p, pEList);
}



/*
** An array of this structure defines a list of keywords.
*/
struct PicWordlist {
  char *zWord;    /* Text of the keyword */
  int nChar;      /* Length of keyword text in bytes */
  int eType;      /* Token code */
};

/*
** Keywords
*/
static struct PicWordlist pic_keywords[] = {
  { "above",      5,   T_ABOVE     },
  { "and",        3,   T_AND       },
  { "angle",      5,   T_ANGLE     },
  { "as",         2,   T_AS        },
  { "at",         2,   T_AT        },
  { "atan2",      5,   T_FUNCNAME  },
  { "behind",     6,   T_BEHIND    },
  { "below",      5,   T_BELOW     },
  { "between",    7,   T_BETWEEN   },
  { "bottom",     6,   T_BOTTOM    },
  { "ccw",        3,   T_CCW       },
  { "center",     6,   T_CENTER    },
  { "chop",       4,   T_CHOP      },
  { "color",      5,   T_COLOR     },
  { "cos",        3,   T_FUNCNAME  },
  { "cw",         2,   T_CW        },
  { "dashed",     6,   T_DASHED    },
  { "diameter",   8,   T_DIAMETER  },
  { "distance",   8,   T_DISTANCE  },
  { "dotted",     6,   T_DOTTED    },
  { "down",       4,   T_DOWN      },
  { "e",          1,   T_EDGE      },
  { "end",        3,   T_END       },
  { "exp",        3,   T_FUNCNAME  },
  { "fill",       4,   T_FILL      },
  { "from",       4,   T_FROM      },
  { "height",     6,   T_HEIGHT    },
  { "in",         2,   T_IN        },
  { "int",        3,   T_FUNCNAME  },
  { "invisible",  9,   T_INVIS     },
  { "last",       4,   T_LAST      },
  { "left",       4,   T_LEFT      },
  { "ljust",      5,   T_LJUST     },
  { "log",        3,   T_FUNCNAME  },
  { "max",        3,   T_FUNCNAME  },
  { "min",        3,   T_FUNCNAME  },
  { "n",          1,   T_EDGE      },
  { "ne",         2,   T_EDGE      },
  { "nw",         2,   T_EDGE      },
  { "of",         2,   T_OF        },
  { "print",      5,   T_PRINT     },
  { "radius",     6,   T_RADIUS    },
  { "right",      5,   T_RIGHT     },
  { "rjust",      5,   T_RJUST     },
  { "rx",         2,   T_RX        },
  { "ry",         2,   T_RY        },
  { "s",          1,   T_EDGE      },
  { "same",       4,   T_SAME      },
  { "se",         2,   T_EDGE      },
  { "sin",        3,   T_FUNCNAME  },
  { "sqrt",       4,   T_FUNCNAME  },
  { "start",      5,   T_START     },
  { "sw",         2,   T_EDGE      },
  { "the",        3,   T_THE       },
  { "then",       4,   T_THEN      },
  { "thickness",  9,   T_THICKNESS },
  { "to",         2,   T_TO        },
  { "top",        3,   T_TOP       },
  { "up",         2,   T_UP        },
  { "w",          1,   T_EDGE      },
  { "way",        3,   T_WAY       },
  { "width",      5,   T_WIDTH     },
  { "with",       4,   T_WITH      },
  { "x",          1,   T_X         },
  { "y",          1,   T_Y         },
};

/*
** Search a PicWordlist for the given keyword.  Return its code.
** Or return 0 if not found.
*/
static int pic_find_word(
  const char *zIn,              /* Word to search for */
  int n,                        /* Length of zIn */
  struct PicWordlist *aList,    /* List to search */
  int nList                     /* Number of entries in aList */
){
  int first = 0;
  int last = nList-1;
  while( first<=last ){
    int mid = (first + last)/2;
    int sz = aList[mid].nChar;
    int c = strncmp(zIn, aList[mid].zWord, sz<n ? sz : n);
    if( c==0 ){
      c = n - sz;
      if( c==0 ) return aList[mid].eType;
    }
    if( c<0 ){
      last = mid-1;
    }else{
      first = mid+1;
    }
  }
  return 0;
}


/*
** Return the length of next token  Write token type into *peType
*/
static int pic_token_length(const char *zStart, int *peType){
  int i;
  char c;
  switch( zStart[0] ){
    case '\\': {
      *peType = T_WHITESPACE;
      if( zStart[1]=='\n'  ) return 2;
      if( zStart[1]=='\r' && zStart[2]=='\n' ) return 3;
      *peType = T_ERROR;
      return 1;
    }
    case ';':
    case '\n': {
      *peType = T_EOL;
      return 1;
    }
    case '"': {
      for(i=1; (c = zStart[i])!=0; i++){
        if( c=='\\' ){ i++; continue; }
        if( c=='"' ){
          *peType = T_STRING;
          return i+1;
        }
      }
      *peType = T_ERROR;
      return i;
    }
    case ' ':
    case '\t':
    case '\f':
    case '\r': {
      for(i=1; (c = zStart[i])==' ' || c=='\t' || c=='\r' || c=='\t'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '#': {
      for(i=1; isxdigit(zStart[i]); i++){}
      if( i==4 || i==7 ){
        *peType = T_HEXRGB;
        return i;
      }
      for(i=1; (c = zStart[i])!=0 && c!='\n'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '+': {   *peType = T_PLUS;    return 1; }
    case '*': {   *peType = T_STAR;    return 1; }
    case '/': {   *peType = T_SLASH;   return 1; }
    case '%': {   *peType = T_PERCENT; return 1; }
    case '(': {   *peType = T_LP;      return 1; }
    case ')': {   *peType = T_RP;      return 1; }
    case '[': {   *peType = T_LB;      return 1; }
    case ']': {   *peType = T_RB;      return 1; }
    case ',': {   *peType = T_COMMA;   return 1; }
    case ':': {   *peType = T_COLON;   return 1; }
    case '=': {   *peType = T_ASSIGN;  return 1; }
    case '-': {
      if( zStart[1]=='>' ){
        *peType = T_RARROW;
        return 2;
      }else{
        *peType = T_MINUS;
        return 1;
      }
    }
    case '<': { 
      if( zStart[1]=='-' ){
         if( zStart[2]=='>' ){
           *peType = T_LRARROW;
           return 3;
         }else{
           *peType = T_LARROW;
           return 2;
         }
      }else{
        *peType = T_ERROR;
         return 1;
      }
    }
    default: {
      c = zStart[0];
      if( c=='.' ){
        char c1 = zStart[1];
        if( c1>='a' && c1<='z' ){
          for(i=2; (c = zStart[i])>='a' && c<='z'; i++){}
          if( T_EDGE==pic_find_word(zStart+1, i-1,
                                    pic_keywords, count(pic_keywords)) ){
            *peType = T_DOT_E;
          }else{
            *peType = T_DOT_L;
          }
          return 1;
        }else if( c1>='0' && c1<='9' ){
          /* no-op.  Fall through to number handling */
        }else if( c1>='A' && c1<='Z' ){
          for(i=2; (c = zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
          *peType = T_DOT_U;
          return 1;
        }else{
          *peType = T_ERROR;
          return 1;
        }
      }
      if( (c>='0' && c<='9') || c=='.' ){
        int nDigit;
        if( c!='.' ){
          nDigit = 1;
          for(i=1; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }else{
          nDigit = 0;
        }
        if( c=='.' ){
          for(i++; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }
        if( nDigit==0 ){
          *peType = T_ERROR;
          return i;
        }
        if( c=='e' || c=='E' ){
          i++;
          c = zStart[i];
          if( c=='+' || c=='-' ){
            i++;
            c = zStart[i];
          }
          if( c<'0' || c>'9' ){
            *peType = T_ERROR;
            return i;
          }
          i++;
          while( (c = zStart[i])>=0 && c<='9' ){ i++; }
        }else if( (c=='t' && zStart[i+1]=='h')
               || (c=='r' && zStart[i+1]=='d')
               || (c=='n' && zStart[i+1]=='d')
               || (c=='s' && zStart[i+1]=='t') ){
          *peType = T_NTH;
          return i+2;
        }
        *peType = T_NUMBER;
        return i;
      }else if( c>='a' && c<='z' ){
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        *peType = pic_find_word(zStart, i,
                   pic_keywords, count(pic_keywords));
        if( *peType==0 ) *peType = T_ID;
        return i;
      }else if( c>='A' && c<='Z' ){
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        *peType = T_PLACENAME;
        return i;
      }else{
        *peType = T_ERROR;
        return 1;
      }
    }
  }
}

/*
** Parse the PIC script contained in zText[]
*/
char *pic(const char *zText, int *pnErr){
  int i;
  int sz;
  int eType;
  PToken token;
  Pic s;
  yyParser sParse;

  memset(&s, 0, sizeof(s));
  s.zIn = zText;
  s.nIn = (unsigned int)strlen(zText);
  pic_parserInit(&sParse, &s);
#if 0
  pic_parserTrace(stdout, "parser: ");
#endif
  for(i=0; zText[i] && s.nErr==0; i+=sz){
    sz = pic_token_length(zText+i, &eType);
    if( eType==T_ERROR ){
      printf("Unknown token at position %d: \"%.*s\"\n", i, sz, zText+i);
      break;
    }else if( eType!=T_WHITESPACE ){
      token.z = zText + i;
      token.n = sz;
      token.eCode = eType;
#if 0
      printf("******** Token %s (%d): \"%.*s\" **************\n",
             yyTokenName[eType], eType,
             isspace(token.z[0]) ? 0 : token.n, token.z);
#endif
      pic_parser(&sParse, eType, token);
    }
  }
  if( s.nErr==0 ){
    memset(&token,0,sizeof(token));
    pic_parser(&sParse, 0, token);
  }
  pic_parserFinalize(&sParse);
  if( pnErr ) *pnErr = s.nErr;
  if( s.zOut ){
    s.zOut[s.nOut] = 0;
    s.zOut = realloc(s.zOut, s.nOut+1);
  }
  return s.zOut;
}

int main(int argc, char **argv){
  int i;
  for(i=1; i<argc; i++){
    FILE *in;
    size_t sz;
    char *zIn;
    char *zOut;

    in = fopen(argv[i], "rb");
    if( in==0 ){
      fprintf(stderr, "cannot open \"%s\" for reading\n", argv[i]);
      continue;
    }
    fseek(in, 0, SEEK_END);
    sz = ftell(in);
    rewind(in);
    zIn = malloc( sz+1 );
    if( zIn==0 ){
      fprintf(stderr, "cannot allocate space for file \"%s\"\n", argv[i]);
      fclose(in);
      continue;
    }
    sz = fread(zIn, 1, sz, in);
    fclose(in);
    zIn[sz] = 0;
    zOut = pic(zIn, 0);
    free(zIn);
    if( zOut ){
      printf("%s", zOut);
      free(zOut);
    }
  }
  return 0; 
}

} // end %code
