%include {
/*
** 2020-09-01
**
** A translator for the PIC language into SVG.
**
** This code was originally written by D. Richard Hipp using documentation
** from prior PIC implementations but without reference to prior code.
** All of the code in this project is original.  The author releases all
** code into the public domain.
**
** This file implements a C-language subroutine that accepts a string
** of PIC language text and generates a second string of SVG output that
** renders the drawing defined by the input.  Space to hold the returned
** string is obtained from malloc() and should be freed by the caller.
** NULL might be returned if there is a memory allocation error.
**
** If there are error in the PIC input, the output will consist of an
** error message and the original PIC input text (inside of <pre>...</pre>).
**
** The subroutine implemented by this file is intended to be stand-alone.
** It uses no external routines other than routines commonly found in
** the standard C library.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#define count(X) (sizeof(X)/sizeof(X[0]))

typedef struct Pic Pic;          /* Complete parsing context */
typedef struct PToken PToken;    /* A single token */
typedef struct PElem PElem;      /* A single element */
typedef struct PEList PEList;    /* A list of elements */
typedef struct PClass PClass;    /* Description of elements types */
typedef double PNum;             /* Numeric value */
typedef struct PPoint PPoint;    /* A position in 2-D space */
typedef struct PVar PVar;        /* script-defined variable */

/* Compass points */
#define CP_N     1
#define CP_NE    2
#define CP_E     3
#define CP_SE    4
#define CP_S     5
#define CP_SW    6
#define CP_W     7
#define CP_NW    8

/* Built-in functions */
#define FN_COS    0
#define FN_INT    1
#define FN_MAX    2
#define FN_MIN    3
#define FN_SIN    4
#define FN_SQRT   5

/* An object to hold a position in 2-D space */
struct PPoint {
  PNum x, y;               /* X and Y coordinates */
};

/* A variable created by the ID = EXPR construct of the PIC script */
struct PVar {
  const char *zName;       /* Name of the variable */
  PNum val;                /* Value of the variable */
  PVar *pNext;             /* Next variable in a list of them all */
};

/* A single token in the parser input stream
*/
struct PToken {
  const char *z;             /* Pointer to the token text */
  unsigned int n;            /* Length of the token in bytes */
  unsigned short int eType;  /* The numeric parser code */
  unsigned short int eCode;  /* Auxiliary code */
};

/* Extra token types not generated by LEMON */
#define T_WHITESPACE 1000
#define T_ERROR      1001

/* Different types of elements */
struct PClass {
  const char *zName;
};

/* A single element */
struct PElem {
  const PClass *type;      /* Element type */
  PEList *pSublist;        /* Substructure for [] elements */
  char *zName;             /* Name assigned to this element */
};

/* A list of elements */
struct PEList {
  int n;          /* Number of elements in the list */
  int nAlloc;     /* Allocated slots in a[] */
  PElem **a;      /* Pointers to individual elements */
};

/* Each call to the pic() subroutine uses an instance of the following
** object to pass around context to all of its subroutines.
*/
struct Pic {
  unsigned nErr;           /* Number of errors seen */
  const char *zIn;         /* Input PIC-language text.  zero-terminated */
  unsigned int nIn;        /* Number of bytes in zIn */
  char *zOut;              /* Result accumulates here */
  unsigned int nOut;       /* Bytes written to zOut[] so far */
  unsigned int nOutAlloc;  /* Space allocated to zOut[] */
  int eDir;                /* Current direction */
  PElem *cur;              /* Element under construction */
  PVar *pVar;              /* Application-defined variables */
};

/* Forward declarations */
static void pic_append(Pic*, const char*,int);
static void pic_append_text(Pic*,const char*,int);
static void pic_error(Pic*,PToken*,const char*);
static void pic_elist_free(Pic*,PEList*);
static void pic_elem_free(Pic*,PElem*);
static void pic_render(Pic*,PEList*);
static PEList *pic_elist_append(Pic*,PEList*,PElem*);
static PElem *pic_elem_new(Pic*,PToken*,PToken*,PEList*);
static void pic_elem_setname(Pic*,PElem*,PToken*);
static void pic_debug_print_expr(Pic*,PNum);
static void pic_set_var(Pic*,PToken*,PNum);
static PNum pic_get_var(Pic*,PToken*);
static PNum pic_color_to_num(Pic*,const char*,int);


} // end %include

%name pic_parser
%token_prefix T_
%token_type {PToken}
%extra_context {Pic *p}

%type element_list {PEList*}
%destructor element_list {pic_elist_free(p,$$);}
%type element {PElem*}
%destructor element {pic_elem_free(p,$$);}
%type unnamed_element {PElem*}
%destructor unnamed_element {pic_elem_free(p,$$);}
%type basetype {PElem*}
%destructor basetype {pic_elem_free(p,$$);}
%type expr {PNum}


document ::= element_list(X).  {pic_render(p,X);}


element_list(A) ::= element(X).   { A = pic_elist_append(p,0,X); }
element_list(A) ::= element_list(B) EOL element(X).
                      { A = pic_elist_append(p,B,X); }


element(A) ::= .   { A = 0; }
element(A) ::= direction.  { A = 0; }
element(A) ::= ID(N) ASSIGN expr(X). {pic_set_var(p,&N,X); A = 0;}
element(A) ::= PRINT expr(X). {pic_debug_print_expr(p,X); A=0;}
element(A) ::= PLACENAME(N) COLON unnamed_element(X).
               { A = X;  pic_elem_setname(p,X,&N); }
element(A) ::= unnamed_element(X).  {A = X;}

unnamed_element(A) ::= basetype(X) attribute_list.  {A = X;}

basetype(A) ::= ID(N).                  {A = pic_elem_new(p,&N,0,0); }
basetype(A) ::= STRING(N).              {A = pic_elem_new(p,0,&N,0); }
basetype(A) ::= LB element_list(X) RB.  {A = pic_elem_new(p,0,0,X);}

direction ::= UP.
direction ::= DOWN.
direction ::= LEFT.
direction ::= RIGHT.

attribute_list ::=.
attribute_list ::= attribute_list attribute.
attribute ::= numproperty expr PERCENT.
attribute ::= numproperty expr.
attribute ::= dashproperty expr.
attribute ::= dashproperty.
attribute ::= colorproperty expr.
attribute ::= direction expr.
attribute ::= direction.
attribute ::= FROM position.
attribute ::= TO position.
attribute ::= THEN.
attribute ::= boolproperty.
attribute ::= AT position.
attribute ::= WITH DOT_E EDGE AT position.
attribute ::= WITH EDGE AT position.
attribute ::= SAME.
attribute ::= SAME AS object.
attribute ::= BEHIND object.
attribute ::= STRING textposition.

// Properties that require an argument
numproperty ::= HEIGHT.
numproperty ::= WIDTH.
numproperty ::= RADIUS.
numproperty ::= RX.
numproperty ::= RY.
numproperty ::= DIAMETER.
numproperty ::= THICKNESS.

// Properties with optional arguments
dashproperty ::= DOTTED.
dashproperty ::= DASHED.
dashproperty ::= CHOP.

// Color properties
colorproperty ::= FILL.
colorproperty ::= COLOR.

// Properties with no argument
boolproperty ::= CW.
boolproperty ::= CCW.
boolproperty ::= LARROW.
boolproperty ::= RARROW.
boolproperty ::= LRARROW.
boolproperty ::= INVIS.

textposition ::= .
textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW.


position ::= expr COMMA expr.
position ::= place.
position ::= place PLUS expr COMMA expr.
position ::= place MINUS expr COMMA expr.
position ::= place PLUS LP expr COMMA expr RP.
position ::= place MINUS LP expr COMMA expr RP.
position ::= LP position COMMA position RP.
position ::= LP position RP.
position ::= expr OF THE WAY BETWEEN position AND position.
position ::= expr BETWEEN position AND position.
position ::= direction expr FROM position.
position ::= DISTANCE expr ANGLE expr FROM position.

place ::= object.
place ::= object DOT_E EDGE.
place ::= object DOT_L START.
place ::= object DOT_L END.
place ::= START OF object.
place ::= END OF object.
place ::= EDGE OF object.

object ::= objectname.
object ::= nth.
object ::= nth OF|IN object.

objectname ::= PLACENAME.
objectname ::= objectname DOT_U PLACENAME.

nth ::= NTH ID.
nth ::= NTH LAST ID.
nth ::= LAST ID.
nth ::= NTH LB RB.
nth ::= NTH LAST LB RB.
nth ::= LAST LB RB.

%left OF.
%left PLUS MINUS.
%left STAR SLASH PERCENT.
%right UMINUS.

expr(A) ::= expr(X) PLUS expr(Y).     {A=X+Y;}
expr(A) ::= expr(X) MINUS expr(Y).    {A=X-Y;}
expr(A) ::= expr(X) STAR expr(Y).     {A=X*Y;}
expr(A) ::= expr(X) SLASH(E) expr(Y).    {
  if( Y==0.0 ){
    pic_error(p, &E, "division by zero");
    A = 0.0;
  }else{
    A = X/Y;
  }
}
expr(A) ::= MINUS expr(X). [UMINUS]  {A=-X;}
expr(A) ::= PLUS expr(X). [UMINUS]   {A=X;}
expr(A) ::= LP expr(X) RP.           {A=X;}
expr(A) ::= NUMBER(N).               {A=atof(N.z);}
expr(A) ::= ID(N).                   {A=pic_get_var(p,&N);}
expr(A) ::= HEXRGB(X).               {A=pic_color_to_num(p,X.z,X.n);}
expr(A) ::= FUNC1(F) LP expr(X) RP. {
  switch( F.eCode ){
    case FN_COS:  A = cos(X);   break;
    case FN_INT:  A = floor(X); break;
    case FN_SIN:  A = sin(X);   break;
    case FN_SQRT:
      if( X<0.0 ){
        pic_error(p, &F, "sqrt of negative value");
        A = 0.0;
      }else{
        A = sqrt(X);
      }
      break;
    default: A = 0.0;
  }
}
expr(A) ::= FUNC2(F) LP expr(X) COMMA expr(Y) RP. {
  switch( F.eCode ){
    case FN_MAX:  A = X>Y ? X : Y;   break;
    case FN_MIN:  A = X<Y ? X : Y;   break;
    default: A = 0.0;
  }
}


expr ::= object DOT_L locproperty.
expr ::= object DOT_L numproperty.
expr ::= object DOT_L dashproperty.
expr ::= object DOT_L colorproperty.
expr ::= LP locproperty OF object RP.
expr ::= LP dashproperty OF object RP.
expr ::= LP numproperty OF object RP.
expr ::= LP colorproperty OF object RP.
expr ::= object DOT_E EDGE DOT_L X.
expr ::= object DOT_E EDGE DOT_L Y.

locproperty ::= X.
locproperty ::= Y.
locproperty ::= TOP.
locproperty ::= BOTTOM.
locproperty ::= LEFT.
locproperty ::= RIGHT.


%code {


/* Chart of the 140 official HTML color names */
static const struct {
  const char *zName;  /* Name of the color */
  unsigned int val;   /* RGB value */
} aColor[] = {
  { "AliceBlue",                   0xf0f8ff },
  { "AntiqueWhite",                0xfaebd7 },
  { "Aqua",                        0x00ffff },
  { "AquaMarine",                  0x7fffd4 },
  { "Azure",                       0xf0ffff },
  { "Beige",                       0xf5f5dc },
  { "Bisque",                      0xffe4c4 },
  { "Black",                       0x000000 },
  { "BlanchedAlmond",              0xffebcd },
  { "Blue",                        0x0000ff },
  { "BlueViolet",                  0x8a2be2 },
  { "Brown",                       0xa52a2a },
  { "BurlyWood",                   0xdeb887 },
  { "CadetBlue",                   0x5f9ea0 },
  { "Chartreuse",                  0x7fff00 },
  { "Chocolate",                   0xd2691e },
  { "Coral",                       0xff7f50 },
  { "CornFlowerBlue",              0x6495ed },
  { "Cornsilk",                    0xfff8dc },
  { "Crimson",                     0xdc143c },
  { "Cyan",                        0x00ffff },
  { "DarkBlue",                    0x00008b },
  { "DarkCyan",                    0x008b8b },
  { "DarkGoldenRod",               0xb8860b },
  { "DarkGray",                    0xa9a9a9 },
  { "DarkGreen",                   0x006400 },
  { "DarkKhaki",                   0xbdb76b },
  { "DarkMagenta",                 0x8b008b },
  { "DarkOliveGreen",              0x556b2f },
  { "DarkOrange",                  0xff8c00 },
  { "DarkOrchid",                  0x9932cc },
  { "DarkRed",                     0x8b0000 },
  { "DarkSalmon",                  0xe9967a },
  { "DarkSeaGreen",                0x8fbc8f },
  { "DarkSlateBlue",               0x483d8b },
  { "DarkSlateGray",               0x2f4f4f },
  { "DarkTurquoise",               0x00ced1 },
  { "DarkViolet",                  0x9400d3 },
  { "DeepPink",                    0xff1493 },
  { "DeepSkyBlue",                 0x00bfff },
  { "DimGray",                     0x696969 },
  { "DodgerBlue",                  0x1e90ff },
  { "FireBrick",                   0xb22222 },
  { "FloralWhite",                 0xfffaf0 },
  { "ForestGreen",                 0x228b22 },
  { "Fuchsia",                     0xff00ff },
  { "Gainsboro",                   0xdcdcdc },
  { "GhostWhite",                  0xf8f8ff },
  { "Gold",                        0xffd700 },
  { "GoldenRod",                   0xdaa520 },
  { "Gray",                        0x808080 },
  { "Green",                       0x008000 },
  { "GreenYellow",                 0xadff2f },
  { "HoneyDew",                    0xf0fff0 },
  { "HotPink",                     0xff69b4 },
  { "IndianRed",                   0xcd5c5c },
  { "Indigo",                      0x4b0082 },
  { "Ivory",                       0xfffff0 },
  { "Khaki",                       0xf0e68c },
  { "Lavender",                    0xe6e6fa },
  { "LavenderBlush",               0xfff0f5 },
  { "LawnGreen",                   0x7cfc00 },
  { "LemonChiffon",                0xfffacd },
  { "LightBlue",                   0xadd8e6 },
  { "LightCoral",                  0xf08080 },
  { "LightCyan",                   0xe0ffff },
  { "LightGoldenrodYellow",        0xfafad2 },
  { "LightGray",                   0xd3d3d3 },
  { "LightGreen",                  0x90ee90 },
  { "LightPink",                   0xffb6c1 },
  { "LightSalmon",                 0xffa07a },
  { "LightSeaGreen",               0x20b2aa },
  { "LightSkyBlue",                0x87cefa },
  { "LightSlateGray",              0x778899 },
  { "LightSteelBlue",              0xb0c4de },
  { "LightYellow",                 0xffffe0 },
  { "Lime",                        0x00ff00 },
  { "LimeGreen",                   0x32cd32 },
  { "Linen",                       0xfaf0e6 },
  { "Magenta",                     0xff00ff },
  { "Maroon",                      0x800000 },
  { "MediumAquaMarine",            0x66cdaa },
  { "MediumBlue",                  0x0000cd },
  { "MediumOrchid",                0xba55d3 },
  { "MediumPurple",                0x9370d8 },
  { "MediumSeaGreen",              0x3cb371 },
  { "MediumSlateBlue",             0x7b68ee },
  { "MediumSpringGreen",           0x00fa9a },
  { "MediumTurquoise",             0x48d1cc },
  { "MediumVioletRed",             0xc71585 },
  { "MidnightBlue",                0x191970 },
  { "MintCream",                   0xf5fffa },
  { "MistyRose",                   0xffe4e1 },
  { "Moccasin",                    0xffe4b5 },
  { "NavajoWhite",                 0xffdead },
  { "Navy",                        0x000080 },
  { "OldLace",                     0xfdf5e6 },
  { "Olive",                       0x808000 },
  { "OliveDrab",                   0x6b8e23 },
  { "Orange",                      0xffa500 },
  { "OrangeRed",                   0xff4500 },
  { "Orchid",                      0xda70d6 },
  { "PaleGoldenRod",               0xeee8aa },
  { "PaleGreen",                   0x98fb98 },
  { "PaleTurquoise",               0xafeeee },
  { "PaleVioletRed",               0xdb7093 },
  { "PapayaWhip",                  0xffefd5 },
  { "PeachPuff",                   0xffdab9 },
  { "Peru",                        0xcd853f },
  { "Pink",                        0xffc0cb },
  { "Plum",                        0xdda0dd },
  { "PowderBlue",                  0xb0e0e6 },
  { "Purple",                      0x800080 },
  { "Red",                         0xff0000 },
  { "RosyBrown",                   0xbc8f8f },
  { "RoyalBlue",                   0x4169e1 },
  { "SaddleBrown",                 0x8b4513 },
  { "Salmon",                      0xfa8072 },
  { "SandyBrown",                  0xf4a460 },
  { "SeaGreen",                    0x2e8b57 },
  { "SeaShell",                    0xfff5ee },
  { "Sienna",                      0xa0522d },
  { "Silver",                      0xc0c0c0 },
  { "SkyBlue",                     0x87ceeb },
  { "SlateBlue",                   0x6a5acd },
  { "SlateGray",                   0x708090 },
  { "Snow",                        0xfffafa },
  { "SpringGreen",                 0x00ff7f },
  { "SteelBlue",                   0x4682b4 },
  { "Tan",                         0xd2b48c },
  { "Teal",                        0x008080 },
  { "Thistle",                     0xd8bfd8 },
  { "Tomato",                      0xff6347 },
  { "Turquoise",                   0x40e0d0 },
  { "Violet",                      0xee82ee },
  { "Wheat",                       0xf5deb3 },
  { "White",                       0xffffff },
  { "WhiteSmoke",                  0xf5f5f5 },
  { "Yellow",                      0xffff00 },
  { "YellowGreen",                 0x9acd32 },
};

/* Built-in variable names */
static const struct { const char *zName; PNum val; } aBuiltin[] = {
  { "arcrad",      0.25 },
  { "arrowhead",   2.0  },
  { "arrowht",     0.1  },
  { "arrowwid",    0.05 },
  { "boxht",       0.5  },
  { "boxwid",      0.75 },
  { "circlerad",   0.25 },
  { "dashwid",     0.1  },
  { "ellipseht",   0.5  },
  { "ellipsewid",  0.75 },
  { "lineht",      0.5  },
  { "linewid",     0.5  },
  { "movewid",     0.5  },
  { "scale",       1.0  },
  { "textht",      0.5  },
  { "textwid",     0.0  },
};



/*
** The following array holds all the different kinds of named
** elements.  The special STRING and [] elements are separate.
*/
static const PClass aClass[] = {
   {  "box",      },
   {  "arrow",    },
   {  "circle",   },
   {  "ellipse",  },
   {  "arc",      },
   {  "line",     },
   {  "spline",   },
   {  "move",     },
   {  "cylinder", },
   {  "document", },
   {  "folder",   }
};
static const PClass sublistClass = { "[]", };
static const PClass textClass = { "TEXT", };


/*
** Append raw text to zOut
*/
static void pic_append(Pic *p, const char *zText, int n){
  if( n<0 ) n = (int)strlen(zText);
  if( p->nOut+n>=p->nOutAlloc ){
    int nNew = (p->nOut+n)*2 + 1;
    char *z = realloc(p->zOut, nNew);
    if( z==0 ){
      pic_error(p, 0, 0);
      return;
    }
    p->zOut = z;
    p->nOutAlloc = n;
  }
  memcpy(p->zOut+p->nOut, zText, n);
  p->nOut += n;
  p->zOut[p->nOut] = 0;
}

/*
** Append text to zOut with HTML characters escaped.
*/
static void pic_append_text(Pic *p, const char *zText, int n){
  int i;
  char c;
  if( n<0 ) n = (int)strlen(zText);
  while( n>0 ){
    for(i=0; i<n && (c=zText[i])!='<' && c!='>' && c!='&' && c!='"'; i++){}
    if( i ) pic_append(p, zText, i);
    if( i==n ) break;
    switch( c ){
      case '<': {  pic_append(p, "&lt;", 4);  break;  }
      case '>': {  pic_append(p, "&gt;", 4);  break;  }
      case '&': {  pic_append(p, "&amp;", 5);  break;  }
      case '"': {  pic_append(p, "&quote;", 7);  break;  }
    }
    i++;
    n -= i;
    zText += i;
    i = 0;
  }
}

/*
** Generate an error message for the output.  pErr is the token at which
** the error should point.  zMsg is the text of the error message. If
** either pErr or zMsg is NULL, generate an out-of-memory error message.
**
** This routine is a no-op if there has already been an error reported.
*/
static void pic_error(Pic *p, PToken *pErr, const char *zMsg){
  int i;
  if( p->nErr ) return;
  p->nErr++;
  i = (int)(pErr->z - p->zIn);
  if( pErr==0 || zMsg==0 ){
    pic_append_text(p, "\n<div><p class='err'>Out of memory</p></div>\n", -1);
    return;
  }
  pic_append(p, "<div><pre>\n", -1);
  pic_append_text(p, p->zIn, i);
  pic_append(p, "<span class='err'>&rarr;", -1);
  pic_append_text(p, p->zIn+i, pErr->n);
  pic_append(p, "&larr;", -1);
  pic_append_text(p, zMsg, -1);
  pic_append(p, "</span>", -1);
  i += pErr->n;
  pic_append_text(p,  p->zIn+i, -1);
  pic_append(p, "\n</pre></div>\n", -1);
}

/* Output an expresion value in a comment for debugging purposes */
static void pic_debug_print_expr(Pic *p, PNum x){
  char zBuf[100];
  pic_append(p, "<!-- ", -1);
  snprintf(zBuf, sizeof(zBuf)-1, "%.10g", (double)x);
  pic_append(p, zBuf, -1);
  pic_append(p, " -->\n", -1);
}


/* Free a complete list of elements */
static void pic_elist_free(Pic *p, PEList *pEList){
  int i;
  if( pEList==0 ) return;
  for(i=0; i<pEList->n; i++){
    pic_elem_free(p, pEList->a[i]);
  }
  free(pEList->a);
  free(pEList);
  return;
}

/* Free a single element, and its substructure */
static void pic_elem_free(Pic *p, PElem *pElem){
  if( pElem==0 ) return;
  free(pElem->zName);
  pic_elist_free(p, pElem->pSublist);
  free(pElem);
}


/* Append a new element onto the end of an element_list.  The
** element_list is created if it does not already exist.  Return
** the new element list.
*/
static PEList *pic_elist_append(Pic *p, PEList *pEList, PElem *pElem){
  if( pElem==0 ) return pEList;
  if( pEList==0 ){
    pEList = malloc(sizeof(*pEList));
    if( pEList==0 ){
      pic_error(p, 0, 0);
      pic_elem_free(p, pElem);
      return 0;
    }
    memset(pEList, 0, sizeof(*pEList));
  }
  if( pEList->n>=pEList->nAlloc ){
    int nNew = (pEList->n+5)*2;
    PElem **pNew = realloc(pEList->a, sizeof(PElem*)*nNew);
    if( pNew==0 ){
      pic_error(p, 0, 0);
      pic_elem_free(p, pElem);
      return pEList;
    }
    pEList->a = pNew;
  }
  pEList->a[pEList->n++] = pElem;   
  return pEList;
}

/* Allocate and return a new PElem object.
*/
static PElem *pic_elem_new(Pic *p, PToken *pId, PToken *pStr, PEList *pSublist){
  PElem *pNew;

  pNew = malloc( sizeof(*pNew) );
  if( pNew==0 ){
    pic_error(p,0,0);
    pic_elist_free(p, pSublist);
    return 0;
  }
  memset(pNew, 0, sizeof(*pNew));
  if( pSublist ){
    pNew->type = &sublistClass;
    pNew->pSublist = pSublist;
    return pNew;
  }
  if( pStr ){
    pNew->type = &textClass;
    return pNew;
  }
  if( pId ){
    int i;
    for(i=0; i<count(aClass); i++){
      if( strncmp(aClass[i].zName, pId->z, pId->n)==0 
       && aClass[i].zName[pId->n]==0
      ){
        pNew->type = &aClass[i];
        return pNew;
      }
    }
    pic_error(p, pId, "unknown element type");
  }
  pic_elem_free(p, pNew);
  return 0;
}

/* Set a local variable name to "val".
**
** The name might be a built-in variable or a color name.  In either case,
** a new application-defined variable is set.  Since app-defined variables
** are searched first, this will override any built-in variables.
*/
static void pic_set_var(Pic *p, PToken *pId, PNum val){
  PVar *pVar = p->pVar;
  while( pVar ){
    if( strncmp(pVar->zName,pId->z,pId->n)==0 && pVar->zName[pId->n]==0 ) break;
    pVar = pVar->pNext;
  }
  if( pVar==0 ){
    char *z;
    pVar = malloc( pId->n+1 + sizeof(*pVar) );
    if( pVar==0 ){
      pic_error(p, 0, 0);
      return;
    }
    pVar->zName = z = (char*)&pVar[1];
    memcpy(z, pId->z, pId->n);
    z[pId->n] = 0;
    pVar->pNext = p->pVar;
    p->pVar = pVar;
  }
  pVar->val = val;
}

/* Get the value of a variable.
**
** Search in order:
**
**    *  Application defined variables
**    *  Built-in variables
**    *  Color names
*/
static PNum pic_get_var(Pic *p, PToken *pId){
  PVar *pVar;
  int first, last, mid, c;
  for(pVar=p->pVar; pVar; pVar=pVar->pNext){
    if( strncmp(pVar->zName,pId->z,pId->n)==0 && pVar->zName[pId->n]==0 ){
      return pVar->val;
    }
  }
  first = 0;
  last = count(aBuiltin)-1;
  while( first<=last ){
    mid = (first+last)/2;
    c = strncmp(pId->z,aBuiltin[mid].zName,pId->n);
    if( c==0 && aBuiltin[mid].zName[pId->n] ) c = 1;
    if( c==0 ) return aBuiltin[mid].val;
    if( c>0 ){
      first = mid+1;
    }else{
      last = mid-1;
    }
  }
  first = 0;
  last = count(aColor)-1;
  while( first<=last ){
    const char *zClr;
    int c1, c2, i;
    mid = (first+last)/2;
    zClr = aColor[mid].zName;
    for(i=0; i<pId->n; i++){
      c1 = zClr[i]&0x7f;
      if( isupper(c1) ) c1 = tolower(c1);
      c2 = pId->z[i]&0x7f;
      if( isupper(c2) ) c2 = tolower(c2);
      c = c2 - c1;
      if( c ) break;
    }
    if( c==0 && aColor[mid].zName[pId->n] ) c = 1;
    if( c==0 ) return (double)aColor[mid].val;
    if( c>0 ){
      first = mid+1;
    }else{
      last = mid-1;
    }
  }
  pic_error(p,pId,"no such variable");
  return 0.0;
}

/*
** Convert a hex digit into an integer
*/
static int pic_hexval(char c){
  if( c>='0' && c<='9' ) return c - '0';
  if( c>='a' && c<='f' ) return (c - 'a')+10;
  if( c>='A' && c<='F' ) return (c - 'A')+10;
  return 0;
}

/*
** Convert an RGV color value of the form #HHH or #HHHHHH into
** a PNum.
*/
static PNum pic_color_to_num(Pic *p, const char *z, int n){
  int x;
  if( n==4 ){
    x = pic_hexval(z[1])*0x110000 
         + pic_hexval(z[2])*0x1100
         + pic_hexval(z[3])*0x11;
  }else if( n==7 ){
    int i;
    for(i=1, x=0; i<=6; i++){
      x = x*16 + pic_hexval(z[i]);
    }
  }
  return (PNum)x;
}

/* Attach a name to an element
*/
static void pic_elem_setname(Pic *p, PElem *pElem, PToken *pName){
  if( pElem==0 ) return;
  if( pName==0 ) return;
  free(pElem->zName);
  pElem->zName = malloc(pName->n+1);
  if( pElem->zName==0 ){
    pic_error(p,0,0);
  }else{
    memcpy(pElem->zName,pName->z,pName->n);
    pElem->zName[pName->n] = 0;
  }
  return;
}

/* Render a single element
*/
static void pic_elem_render(Pic *p, PElem *pElem){
  if( pElem==0 ) return;
  if( pElem->zName ){
    pic_append_text(p, pElem->zName, -1);
    pic_append(p, ": ", 2);
  }
  if( pElem->pSublist ){
    pic_append(p, "[\n", 2);
    pic_render(p,pElem->pSublist);
    pElem->pSublist = 0;
    pic_append(p, "]\n", 2);
  }else{
    pic_append_text(p, pElem->type->zName, -1);
    pic_append(p, "\n", 1);
  }
}

/* Render a list of elements.  Write the SVG into p->zOut.
** Delete the input element_list before returnning.
*/
static void pic_render(Pic *p, PEList *pEList){
  int i;
  if( pEList==0 ) return;
  if( p->nErr==0 ){
    for(i=0; i<pEList->n; i++){
      pic_elem_render(p, pEList->a[i]);
    }
  }
  pic_elist_free(p, pEList);
}



/*
** An array of this structure defines a list of keywords.
*/
typedef struct PicWord {
  char *zWord;                /* Text of the keyword */
  short unsigned int nChar;   /* Length of keyword text in bytes */
  short unsigned int eType;   /* Token code */
  short unsigned int eCode;   /* Extra code for the token */
} PicWord;

/*
** Keywords
*/
static const PicWord pic_keywords[] = {
  { "above",      5,   T_ABOVE,     0         },
  { "and",        3,   T_AND,       0         },
  { "angle",      5,   T_ANGLE,     0         },
  { "as",         2,   T_AS,        0         },
  { "at",         2,   T_AT,        0         },
  { "behind",     6,   T_BEHIND,    0         },
  { "below",      5,   T_BELOW,     0         },
  { "between",    7,   T_BETWEEN,   0         },
  { "bottom",     6,   T_BOTTOM,    0         },
  { "ccw",        3,   T_CCW,       0         },
  { "center",     6,   T_CENTER,    0         },
  { "chop",       4,   T_CHOP,      0         },
  { "color",      5,   T_COLOR,     0         },
  { "cos",        3,   T_FUNC1,     FN_COS    },
  { "cw",         2,   T_CW,        0         },
  { "dashed",     6,   T_DASHED,    0         },
  { "diameter",   8,   T_DIAMETER,  0         },
  { "distance",   8,   T_DISTANCE,  0         },
  { "dotted",     6,   T_DOTTED,    0         },
  { "down",       4,   T_DOWN,      0         },
  { "e",          1,   T_EDGE,      CP_E      },
  { "end",        3,   T_END,       0         },
  { "fill",       4,   T_FILL,      0         },
  { "from",       4,   T_FROM,      0         },
  { "height",     6,   T_HEIGHT,    0         },
  { "in",         2,   T_IN,        0         },
  { "int",        3,   T_FUNC1,     FN_INT    },
  { "invisible",  9,   T_INVIS,     0         },
  { "last",       4,   T_LAST,      0         },
  { "left",       4,   T_LEFT,      0         },
  { "ljust",      5,   T_LJUST,     0         },
  { "max",        3,   T_FUNC2,     FN_MAX    },
  { "min",        3,   T_FUNC2,     FN_MIN    },
  { "n",          1,   T_EDGE,      CP_N      },
  { "ne",         2,   T_EDGE,      CP_NE     },
  { "nw",         2,   T_EDGE,      CP_NW     },
  { "of",         2,   T_OF,        0         },
  { "print",      5,   T_PRINT,     0         },
  { "radius",     6,   T_RADIUS,    0         },
  { "right",      5,   T_RIGHT,     0         },
  { "rjust",      5,   T_RJUST,     0         },
  { "rx",         2,   T_RX,        0         },
  { "ry",         2,   T_RY,        0         },
  { "s",          1,   T_EDGE,      CP_S      },
  { "same",       4,   T_SAME,      0         },
  { "se",         2,   T_EDGE,      CP_SE     },
  { "sin",        3,   T_FUNC1,     FN_SIN    },
  { "sqrt",       4,   T_FUNC1,     FN_SQRT   },
  { "start",      5,   T_START,     0         },
  { "sw",         2,   T_EDGE,      CP_SW     },
  { "the",        3,   T_THE,       0         },
  { "then",       4,   T_THEN,      0         },
  { "thickness",  9,   T_THICKNESS, 0         },
  { "to",         2,   T_TO,        0         },
  { "top",        3,   T_TOP,       0         },
  { "up",         2,   T_UP,        0         },
  { "w",          1,   T_EDGE,      CP_W      },
  { "way",        3,   T_WAY,       0         },
  { "width",      5,   T_WIDTH,     0         },
  { "with",       4,   T_WITH,      0         },
  { "x",          1,   T_X,         0         },
  { "y",          1,   T_Y,         0         },
};

/*
** Search a PicWordlist for the given keyword.  A pointer to the
** element found.  Or return 0 if not found.
*/
static const PicWord *pic_find_word(
  const char *zIn,              /* Word to search for */
  int n,                        /* Length of zIn */
  const PicWord *aList,         /* List to search */
  int nList                     /* Number of entries in aList */
){
  int first = 0;
  int last = nList-1;
  while( first<=last ){
    int mid = (first + last)/2;
    int sz = aList[mid].nChar;
    int c = strncmp(zIn, aList[mid].zWord, sz<n ? sz : n);
    if( c==0 ){
      c = n - sz;
      if( c==0 ) return &aList[mid];
    }
    if( c<0 ){
      last = mid-1;
    }else{
      first = mid+1;
    }
  }
  return 0;
}


/*
** Return the length of next token  Write token type into *peType
*/
static int pic_token_length(const char *zStart, int *peType, int *peCode){
  int i;
  char c;
  switch( zStart[0] ){
    case '\\': {
      *peType = T_WHITESPACE;
      if( zStart[1]=='\n'  ) return 2;
      if( zStart[1]=='\r' && zStart[2]=='\n' ) return 3;
      *peType = T_ERROR;
      return 1;
    }
    case ';':
    case '\n': {
      *peType = T_EOL;
      return 1;
    }
    case '"': {
      for(i=1; (c = zStart[i])!=0; i++){
        if( c=='\\' ){ i++; continue; }
        if( c=='"' ){
          *peType = T_STRING;
          return i+1;
        }
      }
      *peType = T_ERROR;
      return i;
    }
    case ' ':
    case '\t':
    case '\f':
    case '\r': {
      for(i=1; (c = zStart[i])==' ' || c=='\t' || c=='\r' || c=='\t'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '#': {
      for(i=1; isxdigit(zStart[i]); i++){}
      if( i==4 || i==7 ){
        *peType = T_HEXRGB;
        return i;
      }
      for(i=1; (c = zStart[i])!=0 && c!='\n'; i++){}
      *peType = T_WHITESPACE;
      return i;
    }
    case '+': {   *peType = T_PLUS;    return 1; }
    case '*': {   *peType = T_STAR;    return 1; }
    case '/': {   *peType = T_SLASH;   return 1; }
    case '%': {   *peType = T_PERCENT; return 1; }
    case '(': {   *peType = T_LP;      return 1; }
    case ')': {   *peType = T_RP;      return 1; }
    case '[': {   *peType = T_LB;      return 1; }
    case ']': {   *peType = T_RB;      return 1; }
    case ',': {   *peType = T_COMMA;   return 1; }
    case ':': {   *peType = T_COLON;   return 1; }
    case '=': {   *peType = T_ASSIGN;  return 1; }
    case '-': {
      if( zStart[1]=='>' ){
        *peType = T_RARROW;
        return 2;
      }else{
        *peType = T_MINUS;
        return 1;
      }
    }
    case '<': { 
      if( zStart[1]=='-' ){
         if( zStart[2]=='>' ){
           *peType = T_LRARROW;
           return 3;
         }else{
           *peType = T_LARROW;
           return 2;
         }
      }else{
        *peType = T_ERROR;
         return 1;
      }
    }
    default: {
      c = zStart[0];
      if( c=='.' ){
        char c1 = zStart[1];
        if( c1>='a' && c1<='z' ){
          const PicWord *pFound;
          for(i=2; (c = zStart[i])>='a' && c<='z'; i++){}
          pFound = pic_find_word(zStart+1, i-1,
                                    pic_keywords, count(pic_keywords));
          if( pFound && pFound->eType==T_EDGE ){
            *peType = T_DOT_E;
          }else{
            *peType = T_DOT_L;
          }
          return 1;
        }else if( c1>='0' && c1<='9' ){
          /* no-op.  Fall through to number handling */
        }else if( c1>='A' && c1<='Z' ){
          for(i=2; (c = zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
          *peType = T_DOT_U;
          return 1;
        }else{
          *peType = T_ERROR;
          return 1;
        }
      }
      if( (c>='0' && c<='9') || c=='.' ){
        int nDigit;
        if( c!='.' ){
          nDigit = 1;
          for(i=1; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }else{
          nDigit = 0;
        }
        if( c=='.' ){
          for(i++; (c = zStart[i])>='0' && c<='9'; i++){ nDigit++; }
        }
        if( nDigit==0 ){
          *peType = T_ERROR;
          return i;
        }
        if( c=='e' || c=='E' ){
          i++;
          c = zStart[i];
          if( c=='+' || c=='-' ){
            i++;
            c = zStart[i];
          }
          if( c<'0' || c>'9' ){
            *peType = T_ERROR;
            return i;
          }
          i++;
          while( (c = zStart[i])>=0 && c<='9' ){ i++; }
        }else if( (c=='t' && zStart[i+1]=='h')
               || (c=='r' && zStart[i+1]=='d')
               || (c=='n' && zStart[i+1]=='d')
               || (c=='s' && zStart[i+1]=='t') ){
          *peType = T_NTH;
          return i+2;
        }
        *peType = T_NUMBER;
        return i;
      }else if( c>='a' && c<='z' ){
        const PicWord *pFound;
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        pFound = pic_find_word(zStart, i, pic_keywords, count(pic_keywords));
        if( pFound ){
          *peType = pFound->eType;
          *peCode = pFound->eCode;
        }else{
          *peType = T_ID;
        }
        return i;
      }else if( c>='A' && c<='Z' ){
        for(i=1; (c =  zStart[i])!=0 && (isalnum(c) || c=='_'); i++){}
        *peType = T_PLACENAME;
        return i;
      }else{
        *peType = T_ERROR;
        return 1;
      }
    }
  }
}

/*
** Parse the PIC script contained in zText[]
*/
char *pic(const char *zText, int *pnErr){
  int i;
  int sz;
  int eType, eCode;
  PToken token;
  Pic s;
  yyParser sParse;

  memset(&s, 0, sizeof(s));
  s.zIn = zText;
  s.nIn = (unsigned int)strlen(zText);
  pic_parserInit(&sParse, &s);
#if 0
  pic_parserTrace(stdout, "parser: ");
#endif
  for(i=0; zText[i] && s.nErr==0; i+=sz){
    eCode = 0;
    sz = pic_token_length(zText+i, &eType, &eCode);
    token.z = zText + i;
    token.n = sz;
    token.eType = (unsigned short int)eType;
    token.eCode = (unsigned short int)eCode;
    if( sz>0x7fff || eType==T_ERROR ){
      pic_error(&s, &token, "unknown token");
      break;
    }else if( eType!=T_WHITESPACE ){
#if 0
      printf("******** Token %s (%d): \"%.*s\" **************\n",
             yyTokenName[token.eType], eType,
             isspace(token.z[0]) ? 0 : token.n, token.z);
#endif
      pic_parser(&sParse, eType, token);
    }
  }
  if( s.nErr==0 ){
    memset(&token,0,sizeof(token));
    pic_parser(&sParse, 0, token);
  }
  pic_parserFinalize(&sParse);
  while( s.pVar ){
    PVar *pNext = s.pVar->pNext;
    free(s.pVar);
    s.pVar = pNext;
  }
  if( pnErr ) *pnErr = s.nErr;
  if( s.zOut ){
    s.zOut[s.nOut] = 0;
    s.zOut = realloc(s.zOut, s.nOut+1);
  }
  return s.zOut;
}

int main(int argc, char **argv){
  int i;
  for(i=1; i<argc; i++){
    FILE *in;
    size_t sz;
    char *zIn;
    char *zOut;

    in = fopen(argv[i], "rb");
    if( in==0 ){
      fprintf(stderr, "cannot open \"%s\" for reading\n", argv[i]);
      continue;
    }
    fseek(in, 0, SEEK_END);
    sz = ftell(in);
    rewind(in);
    zIn = malloc( sz+1 );
    if( zIn==0 ){
      fprintf(stderr, "cannot allocate space for file \"%s\"\n", argv[i]);
      fclose(in);
      continue;
    }
    sz = fread(zIn, 1, sz, in);
    fclose(in);
    zIn[sz] = 0;
    zOut = pic(zIn, 0);
    free(zIn);
    if( zOut ){
      printf("%s", zOut);
      free(zOut);
    }
  }
  return 0; 
}

} // end %code
